<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GridWatch — City</title>
    <meta
      name="description"
      content="City-specific dashboard for GridWatch with map, incidents, and subsystem panels."
    />
    <meta name="color-scheme" content="light dark" />

    <style>
      :root {
        --bg: #0f1220;
        --panel: #171a2b;
        --panel-2: #1f2340;
        --border: #2a2f55;
        --muted: #9aa3b2;
        --text: #e8ebf4;
        --accent: #7aa8ff;
        --accent-2: #4ce1b6;
        --radius: 14px;
        --shadow: 0 8px 30px rgba(0, 0, 0, 0.35);
        --btn-secondary-bg: var(--card);
        --btn-secondary-fg: var(--text);
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          "Helvetica Neue", Arial;
        color: var(--text);

        /* bigger ellipse, origin pushed farther off-screen, smoother fade */
        background: radial-gradient(
            1600px 1000px at 12% -25%,
            #1a1f3d 0%,
            rgba(26, 31, 61, 0.65) 45%,
            rgba(26, 31, 61, 0) 85%
          ),
          var(--bg);
        background-repeat: no-repeat;
      }
      .wrap {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px 20px 48px;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        margin: 8px 0 18px;
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .logo {
        width: 40px;
        height: 40px;
        border-radius: 10px;
        box-shadow: var(--shadow);
        /* Show the provided grid image inside the same 40×40 square */
        background-image: url("/Grid.png");
        background-size: cover; /* fill the square, crop overflow */
        background-position: center; /* center the image */
        background-repeat: no-repeat;
        display: block;
      }

      h1 {
        margin: 0;
        font-size: clamp(22px, 3vw, 32px);
        letter-spacing: 0.2px;
      }
      .sub {
        color: var(--muted);
        font-size: 13px;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: none;
        cursor: pointer;
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 600;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #0b1020;
        box-shadow: var(--shadow);
        text-decoration: none;
      }
      .btn.secondary {
        background: transparent !important;
        color: var(--btn-secondary-fg) !important;
        border: 1px solid var(--border);
      }
      .btn:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(122, 168, 255, 0.35);
      }

      main {
        display: grid;
        grid-template-columns: 1fr;
        gap: 22px;
      }
      @media (max-width: 980px) {
        main {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
      }
      .card {
        background: #0d1022;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 14px;
      }
      .panel h2 {
        margin: 0;
        padding: 14px 16px;
        font-size: 18px;
      }

      .grid {
        display: grid;
        gap: 14px;
      }
      .metrics {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
      }
      @media (max-width: 700px) {
        .metrics {
          grid-template-columns: 1fr 1fr;
        }
      }

      .stat {
        background: #0d1022;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
      }
      .stat .k {
        font-size: 22px;
        font-weight: 700;
      }
      .stat .t {
        color: var(--muted);
        font-size: 12px;
      }

      #map {
        height: 420px;
        border-radius: 12px;
      }

      ul.clean {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      ul.clean li {
        border-bottom: 1px solid #181c36;
        padding: 10px 2px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      ul.clean li:last-child {
        border-bottom: none;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #0f1430;
        border: 1px solid var(--border);
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        color: var(--muted);
      }
      .sev-hi {
        background: rgba(255, 88, 88, 0.1);
        border-color: #6b1a1a;
        color: #ff8f8f;
      }
      .sev-med {
        background: rgba(255, 200, 88, 0.08);
        border-color: #5b481a;
        color: #ffd890;
      }
      .sev-low {
        background: rgba(100, 240, 180, 0.08);
        border-color: #2a5b4a;
        color: #9bf3cf;
      }

      .muted {
        color: var(--muted);
      }
      /* ===== THEME FOUNDATION ===== */
      :root {
        color-scheme: light dark;

        /* Light defaults */
        --bg: #f6f8fb;
        --panel: #ffffff;
        --panel-2: #f6f8ff;
        --border: #d9dfec;
        --muted: #667085;
        --text: #111322;
        --accent: #7aa8ff;
        --accent-2: #4ce1b6;
        --radius: 14px;
        --shadow: 0 6px 24px rgba(0, 0, 0, 0.08);

        --card: #ffffff;
        --line: #e6eaf5;

        /* severity chips (light) */
        --sev-hi-bg: rgba(255, 59, 48, 0.08);
        --sev-hi-bd: #ff3b30;
        --sev-hi-tx: #b3261e;
        --sev-med-bg: rgba(255, 186, 0, 0.1);
        --sev-med-bd: #f2a60c;
        --sev-med-tx: #7a5800;
        --sev-low-bg: rgba(16, 185, 129, 0.1);
        --sev-low-bd: #2ea37d;
        --sev-low-tx: #0f5132;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --btn-secondary-bg: #0f1430;
          --btn-secondary-fg: var(--text);
          --bg: #0f1220;
          --panel: #171a2b;
          --panel-2: #1f2340;
          --border: #2a2f55;
          --muted: #9aa3b2;
          --text: #e8ebf4;
          --shadow: 0 8px 30px rgba(0, 0, 0, 0.35);

          --card: #0d1022;
          --line: #181c36;

          --sev-hi-bg: rgba(255, 88, 88, 0.1);
          --sev-hi-bd: #6b1a1a;
          --sev-hi-tx: #ff8f8f;
          --sev-med-bg: rgba(255, 200, 88, 0.08);
          --sev-med-bd: #5b481a;
          --sev-med-tx: #ffd890;
          --sev-low-bg: rgba(100, 240, 180, 0.08);
          --sev-low-bd: #2a5b4a;
          --sev-low-tx: #9bf3cf;
        }
      }

      /* Apply variables to existing blocks */
      body {
        background: radial-gradient(
            1600px 1000px at 12% -25%,
            #e9eefc 0%,
            rgba(233, 238, 252, 0.65) 45%,
            rgba(233, 238, 252, 0) 85%
          ),
          var(--bg);
        color: var(--text);
        background-repeat: no-repeat !important;
      }
      @media (prefers-color-scheme: dark) {
        body {
          background: radial-gradient(
              1600px 1000px at 12% -25%,
              #1a1f3d 0%,
              rgba(26, 31, 61, 0.65) 45%,
              rgba(26, 31, 61, 0) 85%
            ),
            var(--bg);
          background-repeat: no-repeat !important;
        }
      }

      .panel {
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border: 1px solid var(--border);
      }
      .card,
      .stat,
      #map {
        background: var(--card);
        border: 1px solid var(--border);
      }
      ul.clean li {
        border-bottom: 1px solid var(--line);
      }
      .muted,
      .sub {
        color: var(--muted);
      }

      .badge {
        background: var(--card);
        border: 1px solid var(--border);
        color: var(--muted);
      }
      .sev-hi {
        background: var(--sev-hi-bg);
        border-color: var(--sev-hi-bd);
        color: var(--sev-hi-tx);
      }
      .sev-med {
        background: var(--sev-med-bg);
        border-color: var(--sev-med-bd);
        color: var(--sev-med-tx);
      }
      .sev-low {
        background: var(--sev-low-bg);
        border-color: var(--sev-low-bd);
        color: var(--sev-low-tx);
      }
      @media (prefers-color-scheme: light) {
        body {
          background: radial-gradient(
              1800px 1200px at -10% -25%,
              #e9eefc 0%,
              rgba(233, 238, 252, 0.65) 45%,
              rgba(233, 238, 252, 0) 85%
            ),
            var(--bg);
        }
      }
      /* keep the bar off the very edges + respect the iOS home bar */
      #dock {
        left: 50%;
        transform: translateX(-50%);
        bottom: calc(18px + env(safe-area-inset-bottom));
        width: min(75vw, 400px);
      }

      /* make the corners truly rounded and clip the blur */
      #dockInner {
        border-radius: 22px;
        /* Allow the floating labels to escape the dock so they can be shown on hover.
           We keep the rounded corners via clip-path and the backdrop blur for visual effect. */
        overflow: visible; /* allow labels to render above the dock */
        background-clip: padding-box; /* avoid bleed under border */
        -webkit-backdrop-filter: blur(6px); /* Safari */
        backdrop-filter: blur(6px);

        /* Safari fallback when transforms are involved */
        /* Removing clip-path so floating labels can escape the dock without being clipped.
        The rounded corners are preserved via border-radius; if you need the strict
        clip for a specific Safari bug, we can instead render labels outside the
        dock DOM or use JS to position fixed labels. */
        /* clip-path: inset(0 round 22px); */
        transition: transform 160ms ease, box-shadow 160ms ease;
      }

      /* Stop hover “pop” from spilling past the curve on touch */
      @media (hover: none) {
        .dock-item:hover {
          transform: none;
          box-shadow: none;
        }
      }

      .dock-item {
        width: 56px;
        height: 56px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        cursor: pointer;
        transition: transform 160ms cubic-bezier(0.2, 0.9, 0.2, 1),
          box-shadow 160ms ease;
      }
      .dock-item img {
        width: 36px;
        height: 36px;
        display: block;
        pointer-events: none;
      }
      .dock-ico {
        font-size: 22px;
        line-height: 1;
      }
      .dock-item:hover {
        transform: translateY(-8px) scale(1.08);
        box-shadow: 0 12px 30px rgba(2, 6, 23, 0.45);
      }
      .dock-label {
        position: absolute;
        bottom: 64px;
        left: 50%;
        transform: translateX(-50%) translateY(6px);
        background: var(--card);
        color: var(--muted);
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid var(--border);
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        z-index: 1400; /* make sure label appears above the dock */
        pointer-events: none;
        transition: opacity 140ms ease, transform 140ms ease;
      }
      .dock-item:hover .dock-label {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      /* Popover card styles */
      #subsystem-popover .card {
        margin: 8px;
      }
      .dock-item.active {
        transform: translateY(-4px) scale(1.05);
        outline: 2px solid var(--border);
        border-radius: 12px;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin
    ></script>
    <script src="/js/api.js?v=2"></script>
    <link rel="preload" as="image" href="/Grid.png" />
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1 id="cityName">GridWatch</h1>
            <div class="sub" id="subhead">Live dashboard</div>
          </div>
        </div>
        <div style="display: flex; gap: 8px; align-items: center">
          <a href="/?noredirect=1" class="btn secondary" id="backBtn">← Back</a>
          <button class="btn" id="printBtn">Print report</button>
        </div>
      </header>

      <main>
        <!-- Left: Map + Incidents -->
        <section class="panel" aria-labelledby="mapHdr">
          <h2 id="mapHdr">Map</h2>
          <div class="grid" style="padding: 0 14px 14px">
            <div id="map" class="card"></div>

            <div class="metrics">
              <div class="stat">
                <div class="k" id="m-outages">0</div>
                <div class="t">Active utility outages</div>
              </div>
              <div class="stat">
                <div class="k" id="m-incidents">0</div>
                <div class="t">Incidents today</div>
              </div>
              <div class="stat">
                <div class="k" id="m-avgEta">–</div>
                <div class="t">Avg. ETA to resolve</div>
              </div>
            </div>

            <div class="card" id="incidentsCard">
              <div
                style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  margin-bottom: 8px;
                "
              >
                <h3 style="margin: 0">Incidents</h3>
                <span class="badge" id="incidentsBadge">0 open</span>
              </div>
              <ul class="clean" id="incidentsList"></ul>
              <div class="muted" id="incidentsEmpty">No incidents yet.</div>
            </div>
          </div>
        </section>

        <!-- Subsystems replaced by sticky dock (MacOS style) -->
        <div
          id="subsystem-popover"
          class="panel"
          role="dialog"
          aria-hidden="true"
          style="
            display: none;
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 96px;
            width: 520px;
            max-width: 94%;
            z-index: 1200;
          "
        >
          <h2 id="popoverHdr" style="display: none">Subsystem</h2>
          <div
            class="grid"
            style="padding: 0 14px 14px"
            id="popoverContent"
          ></div>
        </div>

        <!-- Sticky Dock Footer (MacOS-like) -->
        <nav
          id="dock"
          aria-label="Subsystem dock"
          style="
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 18px;
            z-index: 1300;
          "
        >
          <div
            id="dockInner"
            style="
              display: flex;
              justify-content: center;
              gap: 18px;
              align-items: flex-end;
              padding: 10px 18px;
              border-radius: 24px;
              background: linear-gradient(
                180deg,
                rgba(255, 255, 255, 0.06),
                rgba(255, 255, 255, 0.02)
              );
              box-shadow: 0 8px 24px rgba(2, 6, 23, 0.5);
              backdrop-filter: blur(6px);
            "
          >
            <!-- Dock items inserted by JS -->
          </div>
        </nav>
      </main>
    </div>

    <script>
      const incidentMarkers = [];
      let allIncidents = [];
      let activeFilter = null;
      const FILTERABLE_IDS = new Set([
        "outage",
        "traffic",
        "crime",
        "environment",
        "emergency",
      ]);

      function labelFor(id) {
        const s =
          typeof SUBSYSTEMS !== "undefined" && Array.isArray(SUBSYSTEMS)
            ? SUBSYSTEMS.find((x) => x.id === id)
            : null;
        return s ? s.label : id || "";
      }

      // Use the cat property from backend, with fallback inference
      function inferCategory(incident) {
        // If backend provides category, use it
        if (incident.cat) {
          return incident.cat;
        }

        // Fallback to title-based inference
        const title = incident.title || incident.t || "";
        const t = String(title).toLowerCase();
        if (
          t.includes("traffic") ||
          t.includes("collision") ||
          t.includes("congestion") ||
          t.includes("road")
        )
          return "traffic";
        if (
          t.includes("robbery") ||
          t.includes("assault") ||
          t.includes("burglary") ||
          t.includes("shots") ||
          t.includes("crime")
        )
          return "crime";
        if (
          t.includes("wildfire") ||
          t.includes("smoke") ||
          t.includes("air") ||
          t.includes("heat") ||
          t.includes("flood")
        )
          return "environment";
        if (
          t.includes("fire") ||
          t.includes("ems") ||
          t.includes("medical") ||
          t.includes("rescue")
        )
          return "emergency";
        if (
          t.includes("outage") ||
          t.includes("service") ||
          t.includes("fiber") ||
          t.includes("internet") ||
          t.includes("power") ||
          t.includes("water") ||
          t.includes("gas")
        )
          return "outage";
        return "outage";
      }

      function setActiveFilter(id) {
        if (!FILTERABLE_IDS.has(id)) return; // ignore non-filter dock items
        activeFilter = activeFilter === id ? null : id; // toggle on/off
        document
          .querySelectorAll("#dockInner .dock-item")
          .forEach((d) =>
            d.classList.toggle("active", d.dataset.id === activeFilter)
          );
        if (Array.isArray(allIncidents)) renderIncidents(allIncidents); // re-render using wrapper below
      }

      function updateIncidentsUIExtras(rows) {
        const badge = document.getElementById("incidentsBadge");
        if (badge) {
          const suffix = activeFilter ? " • " + labelFor(activeFilter) : "";
          badge.textContent = `${rows.length} open${suffix}`;
        }
      }

      // ===== Helpers =====
      const $ = (sel, root = document) => root.querySelector(sel);
      const params = new URLSearchParams(location.search);
      const cityName =
        decodeURIComponent(params.get("name") || "").trim() || "Unknown City";

      try {
        if (localStorage.getItem("gw:remember") === "1")
          localStorage.setItem(
            "gw:selected",
            JSON.stringify({ name: cityName })
          );
      } catch {}

      function toPrettyPath(full) {
        const [cityRaw, stateRaw = ""] = full.split(",").map((s) => s.trim());
        const norm = (s) => s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        // Preserve real hyphens in the slug with `--`, use `-` for spaces
        const citySlug = norm(cityRaw)
          .replace(/-/g, "--") // real hyphens -> double hyphen
          .replace(/\s+/g, "-") // spaces -> single hyphen
          .replace(/[^A-Za-z0-9-]/g, "");
        const state = norm(stateRaw)
          .replace(/[^A-Za-z]/g, "")
          .slice(0, 2)
          .toUpperCase();
        return `/${citySlug}-${state}`;
      }

      // If we arrived via /city.html?name=..., swap the URL to the pretty form
      (function () {
        const params = new URLSearchParams(location.search);
        const name = params.get("name");
        if (name) {
          history.replaceState({ city: name }, "", toPrettyPath(name)); // updates URL without new history entry
        }
      })();

      const KNOWN = {
        "New York, NY": [40.7128, -74.006],
        "Los Angeles, CA": [34.0522, -118.2437],
        "Chicago, IL": [41.8781, -87.6298],
        "Houston, TX": [29.7604, -95.3698],
        "Phoenix, AZ": [33.4484, -112.074],
        "San Francisco, CA": [37.7749, -122.4194],
        "Seattle, WA": [47.6062, -122.3321],
        "Denver, CO": [39.7392, -104.9903],
        "Boston, MA": [42.3601, -71.0589],
        "Austin, TX": [30.2672, -97.7431],
        "Miami, FL": [25.7617, -80.1918],
        "Dallas, TX": [32.7767, -96.797],
        "Washington, DC": [38.9072, -77.0369],
        "Atlanta, GA": [33.749, -84.388],
        "Colorado Springs, CO": [38.8339, -104.8214],
      };

      document.title = `${cityName}`;
      $("#cityName").textContent = cityName;
      $(
        "#subhead"
      ).textContent = `Live dashboard • ${new Date().toLocaleString()}`;

      // ===== Map =====
      async function geocodeCity(name) {
        const key = "gw:geo:" + name;
        try {
          const cached = localStorage.getItem(key);
          if (cached) return JSON.parse(cached);
        } catch {}
        if (KNOWN[name]) {
          const o = { lat: KNOWN[name][0], lon: KNOWN[name][1], name };
          localStorage.setItem(key, JSON.stringify(o));
          return o;
        }
        try {
          const url =
            "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" +
            encodeURIComponent(name);
          const res = await fetch(url, {
            headers: { "Accept-Language": "en" },
          });
          const [hit] = res.ok ? await res.json() : [];
          if (hit) {
            const o = {
              lat: parseFloat(hit.lat),
              lon: parseFloat(hit.lon),
              name,
            };
            localStorage.setItem(key, JSON.stringify(o));
            return o;
          }
        } catch {}
        return { lat: 39.5, lon: -98.35, name: "United States" };
      }

      let map, marker, mapCenter;
      async function initMap() {
        const geo = await geocodeCity(cityName);
        const center = [geo.lat, geo.lon];
        map = L.map("map").setView(center, 11);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution: "&copy; OpenStreetMap",
        }).addTo(map);
        marker = L.marker(center).addTo(map).bindPopup(cityName).openPopup();
        setTimeout(() => map?.invalidateSize(), 50);
      }

      // ===== Real data from backend =====
      const api = new GridWatchAPI(
        "https://gridwatch-backend-554454627121.us-east1.run.app"
      );
      console.log("API Base URL:", api.baseURL);

      async function loadRealIncidents() {
        try {
          console.log("Attempting to load incidents from:", api.baseURL);
          const incidents = await api.getIncidents();
          console.log("Successfully loaded incidents:", incidents.length);
          return incidents.map((incident) => api.transformIncident(incident));
        } catch (error) {
          console.error("Failed to load incidents:", error);
          console.error("API Base URL was:", api.baseURL);
          // Fallback to fake data if backend is unavailable
          return fakeIncidents();
        }
      }

      // Fallback fake data for when backend is unavailable
      function fakeIncidents() {
        const pool = [
          {
            t: "Power outage",
            sev: "hi",
            where: "Downtown",
            eta: "2h",
          },
          {
            t: "Traffic collision",
            sev: "med",
            where: "I-7 W ramp",
            eta: "45m",
          },
          {
            t: "Water service disruption",
            sev: "med",
            where: "Uptown",
            eta: "3h",
          },
          {
            t: "Fiber cut (ISP)",
            sev: "hi",
            where: "Tech District",
            eta: "4h",
          },
          {
            t: "Minor flooding",
            sev: "low",
            where: "Riverside",
            eta: "6h",
          },
        ];
        // Pick 2–5 at random
        const n = Math.floor(Math.random() * 4) + 2;
        return Array.from(
          { length: n },
          (_, i) =>
            pool[(i + Math.floor(Math.random() * pool.length)) % pool.length]
        );
      }

      function renderIncidents(rows) {
        const list = $("#incidentsList");
        const empty = $("#incidentsEmpty");
        list.innerHTML = rows
          .map(
            (r) => `
            <li>
              <div>
                <div style="font-weight:600">${r.title || r.t}</div>
                <div class="muted" style="font-size:12px">${r.where}</div>
              </div>
              <span class="badge ${
                r.severity === "hi" || r.sev === "hi"
                  ? "sev-hi"
                  : r.severity === "med" || r.sev === "med"
                  ? "sev-med"
                  : "sev-low"
              }">ETA ${r.eta}</span>
            </li>`
          )
          .join("");
        empty.style.display = rows.length ? "none" : "block";
        $("#incidentsBadge").textContent = `${rows.length} open`;
        $("#m-incidents").textContent = rows.length.toString();
        $("#m-outages").textContent = rows
          .filter(
            (r) => r.cat === "outage" || /outage|fiber/i.test(r.title || r.t)
          )
          .length.toString();
        $("#m-avgEta").textContent = approxAvgEta(rows);
      }

      function approxAvgEta(rows) {
        if (!rows.length) return "–";
        const mins = rows.map((r) => {
          const m = /([0-9]+)\s*(h|m)/i.exec(r.eta) || [0, 0, "m"];
          return m[2].toLowerCase() === "h"
            ? parseInt(m[1]) * 60
            : parseInt(m[1]);
        });
        const avg = Math.round(mins.reduce((a, b) => a + b, 0) / mins.length);
        return avg >= 60 ? `${Math.round(avg / 60)}h` : `${avg}m`;
      }

      function renderList(el, items) {
        el.innerHTML = items
          .map(
            (i) =>
              `<li><span>${i.label}</span><span class="badge ${
                i.variant || ""
              }">${i.value}</span></li>`
          )
          .join("");
      }

      // Subsystems data and dock behavior
      const SUBSYSTEMS = [
        {
          id: "outage",
          label: "Outage",
          icon: "⚡",
          items: [
            { label: "Power", value: "2 outages", variant: "sev-med" },
            { label: "Internet", value: "1 outage", variant: "sev-med" },
            { label: "Water service", value: "Normal", variant: "sev-low" },
          ],
        },
        {
          id: "traffic",
          label: "Traffic",
          icon: "🚦",
          items: [
            { label: "Avg. speed (citywide)", value: "27 mph" },
            { label: "Major incidents", value: "1", variant: "sev-med" },
            { label: "Road closures", value: "2", variant: "sev-med" },
          ],
        },
        {
          id: "crime",
          label: "Crime",
          icon: "🚓",
          items: [
            { label: "Active alerts", value: "3", variant: "sev-med" },
            { label: "New reports (24h)", value: "12" },
          ],
        },
        {
          id: "environment",
          label: "Environment",
          icon: "🌳",
          items: [
            { label: "Air quality (AQI)", value: "42" },
            { label: "Flood alerts", value: "None", variant: "sev-low" },
          ],
        },
        {
          id: "emergency",
          label: "Emergency",
          icon: "🚑",
          items: [
            { label: "Active incidents", value: "3", variant: "sev-med" },
            { label: "Avg response time", value: "7 min" },
          ],
        },
      ];

      function makeDockItem(s) {
        const el = document.createElement("div");
        el.className = "dock-item";
        el.setAttribute("role", "button");
        el.setAttribute("tabindex", "0");
        el.dataset.id = s.id;
        el.innerHTML = `
              <div class="dock-ico" aria-hidden="true">${s.icon}</div>
              <div class="dock-label">${s.label}</div>
            `;
        el.addEventListener("click", (e) => {
          e.stopPropagation();
          setActiveFilter(s.id);
          togglePopover(s.id);
        });
        el.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            togglePopover(s.id);
          }
        });
        return el;
      }

      function renderDock() {
        const container =
          document.getElementById("dockInner") ||
          document.querySelector("#dockInner");
        if (!container) {
          // If the DOM isn't ready for some reason, try again after DOMContentLoaded
          document.addEventListener("DOMContentLoaded", function onReady() {
            document.removeEventListener("DOMContentLoaded", onReady);
            renderDock();
          });
          return;
        }
        container.innerHTML = "";
        SUBSYSTEMS.forEach(function (s) {
          container.appendChild(makeDockItem(s));
        });
      }

      function openPopover(id) {
        const s = SUBSYSTEMS.find((x) => x.id === id);
        if (!s) return;
        popoverContent.innerHTML =
          '<div class="card">' +
          '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">' +
          '<h3 style="margin:0">' +
          s.label +
          "</h3>" +
          '<button class="btn secondary" id="closePopover">Close</button>' +
          "</div>" +
          '<ul class="clean">' +
          s.items
            .map(function (i) {
              return (
                "<li><span>" +
                i.label +
                '</span><span class="badge ' +
                (i.variant || "") +
                '">' +
                i.value +
                "</span></li>"
              );
            })
            .join("") +
          "</ul>" +
          "</div>";
        popover.style.display = "block";
        popover.setAttribute("aria-hidden", "false");
        // wire up close button
        const cb = document.getElementById("closePopover");
        if (cb) cb.addEventListener("click", closePopover);
      }

      function closePopover() {
        popover.style.display = "none";
        popover.setAttribute("aria-hidden", "true");
      }

      function togglePopover(id) {
        if (popover.style.display === "block") {
          // if same, close; otherwise open new
          const openId = popover.dataset.openId;
          if (openId === id) {
            closePopover();
            return;
          }
        }
        popover.dataset.openId = id;
        openPopover(id);
      }

      // close popover when clicking outside dock or popover
      document.addEventListener("click", (e) => {
        const withinDock = e.target.closest && e.target.closest("#dock");
        const withinPop =
          e.target.closest && e.target.closest("#subsystem-popover");
        if (!withinDock && !withinPop) closePopover();
      });
      // close on Escape
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closePopover();
      });

      // Render dock on boot
      function initDock() {
        renderDock();
      }

      // ===== Actions =====
      $("#printBtn").addEventListener("click", () => window.print());

      // Ensure Leaflet's CSS is actually applied (otherwise tiles "escape")
      function ensureLeafletCSS() {
        return new Promise((resolve) => {
          // Detect whether the .leaflet-container rule is active
          const probe = document.createElement("div");
          probe.style.cssText = "position:absolute;left:-9999px;top:-9999px";
          probe.className = "leaflet-container";
          document.body.appendChild(probe);
          const ok = getComputedStyle(probe).position === "relative";
          document.body.removeChild(probe);
          if (ok) return resolve();

          // Fallback CSS if the first CDN failed
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.href =
            "https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css";
          link.onload = () => resolve();
          document.head.appendChild(link);
        });
      }

      async function ensureLeafletJS() {
        if (window.L) return;
        await new Promise((res, rej) => {
          const s = document.createElement("script");
          s.src = "https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js";
          s.crossOrigin = "";
          s.onload = res;
          s.onerror = () => rej(new Error("Leaflet failed to load"));
          document.head.appendChild(s);
        });
      }

      // === 2) helpers: place markers + ping one ===
      function placeIncidentMarkers(rows) {
        if (!map) return;
        // clear previous
        incidentMarkers.forEach((m) => map.removeLayer(m));
        incidentMarkers.length = 0;

        // quick demo coords: jitter around city center if none provided
        const jitter = (v) => v + (Math.random() - 0.5) * 0.04; // ~a few km
        rows.forEach((r, i) => {
          const lat = r.lat ?? jitter(mapCenter[0]);
          const lon = r.lon ?? jitter(mapCenter[1]);
          const m = L.marker([lat, lon])
            .addTo(map)
            .bindPopup(`${r.title || r.t}<br><small>${r.where}</small>`);
          incidentMarkers[i] = m;
        });
      }

      function pingIncident(i) {
        const m = incidentMarkers[i];
        if (!m) return;
        const ll = m.getLatLng();
        map.flyTo(ll, Math.max(map.getZoom(), 13), { duration: 0.6 }); // smooth focus
        m.openPopup();
        const ring = L.circle(ll, {
          radius: 250,
          color: "#7aa8ff",
          weight: 2,
          fillOpacity: 0.1,
        }).addTo(map);
        setTimeout(() => map.removeLayer(ring), 800); // brief “ping” ring
      }

      const _renderIncidents = renderIncidents;
      renderIncidents = function (rows) {
        try {
          // Remember the full set given to us; tag each with a category if not present
          allIncidents = (rows || []).map((r) =>
            r && typeof r === "object"
              ? { ...r, cat: r.cat || inferCategory(r) }
              : r
          );

          const toShow = activeFilter
            ? allIncidents.filter((r) => r && r.cat === activeFilter)
            : allIncidents;

          _renderIncidents(toShow);
          placeIncidentMarkers(toShow);

          // Rebind “ping” for the filtered list
          [...document.querySelectorAll("#incidentsList li")].forEach(
            (li, i) => {
              li.onclick = () => pingIncident(i);
            }
          );

          updateIncidentsUIExtras(toShow);
        } catch (e) {
          // Safe fallback
          _renderIncidents(rows || []);
          placeIncidentMarkers(rows || []);
          [...document.querySelectorAll("#incidentsList li")].forEach(
            (li, i) => {
              li.onclick = () => pingIncident(i);
            }
          );
        }
      };

      (async function () {
        try {
          await ensureLeafletCSS();
          // If the first CDN (unpkg) didn’t define L, pull a fallback source
          await ensureLeafletJS();

          // If you want to allow direct lat/lon: /city.html?lat=38.9072&lon=-77.0369&z=12
          const p = new URLSearchParams(location.search);
          const qLat = parseFloat(p.get("lat"));
          const qLon = parseFloat(p.get("lon"));
          const qZoom = parseInt(p.get("z") || "11", 10);

          // Your existing geocode + map init, with a raw-lat/lon override
          const geo = await geocodeCity(cityName);
          const center =
            !Number.isNaN(qLat) && !Number.isNaN(qLon)
              ? [qLat, qLon]
              : [geo.lat, geo.lon];

          // const map = L.map("map").setView(center, qZoom);
          map = L.map("map").setView(center, qZoom);
          mapCenter = center;
          L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: "© OpenStreetMap contributors",
          }).addTo(map);

          L.marker(center).addTo(map).bindPopup(cityName).openPopup();
          setTimeout(() => map.invalidateSize(), 50);
        } catch (err) {
          console.warn("Map boot failed:", err);
        }

        try {
          initDock();
        } catch (err) {
          console.error("initDock failed:", err);
        }
        try {
          // Load real incidents from backend
          loadRealIncidents().then((incidents) => {
            // Data is already transformed in loadRealIncidents
            renderIncidents(incidents);

            // Start polling for updates every 30 seconds
            api.startPolling(30000, (newIncidents) => {
              const transformed = newIncidents.map((incident) =>
                api.transformIncident(incident)
              );
              renderIncidents(transformed);
            });
          });
        } catch (err) {
          console.warn("renderIncidents failed:", err);
        }
      })();
    </script>
  </body>
</html>
